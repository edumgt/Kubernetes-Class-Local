# 노드 IP / Internal IP / Cluster IP 정리 (k3s + VirtualBox 실습 환경)

작성 기준: 사용자가 제공한 출력(`kubectl get nodes -o wide`, `ip -br a`, `ip route`, `kubectl get svc -A -o wide`)을 토대로 설명합니다.

---

## 1. 용어부터 한 번에 정리

### 1) Node IP (노드 IP)
- **의미:** 각 노드(서버/VM) 자체가 가진 IP (네트워크 인터페이스에 실제로 붙는 IP)
- **역할:** 노드에 SSH 접속, 노드 OS 레벨 통신, (NodePort/HostNetwork 등에서) 외부 접근의 “입구”가 될 수 있음
- **특징:** 노드에는 NIC가 여러 개일 수 있어 **Node IP가 여러 개**일 수 있음 (예: NAT용, Host-Only용)

### 2) Internal IP (노드의 Internal IP)
- **의미:** Kubernetes가 노드를 식별/통신할 때 대표로 쓰는 **노드의 IP**
- **어디서 보나:** `kubectl get nodes -o wide` 의 `INTERNAL-IP`
- **누가 쓰나:** 컨트롤 플레인 ↔ 워커 통신, kubelet 통신, 노드 간 통신 등
- **핵심:** Internal IP는 **노드 레벨 IP**이며, Service의 ClusterIP와 완전히 다른 개념

### 3) ClusterIP (서비스의 ClusterIP)
- **의미:** `Service`(특히 ClusterIP 타입)에 할당되는 **클러스터 내부 전용 가상 IP(VIP)**
- **역할:** 여러 Pod(Endpoints) 앞에서 **로드밸런싱 + 고정 접점** 제공
- **접근 범위:** 기본적으로 **클러스터 내부에서만 접근**
- **핵심:** ClusterIP는 노드 NIC에 붙는 IP가 아니라, kube-proxy(iptables/ipvs) 규칙으로 구현되는 **논리적(가상) IP**

---

# kube-proxy(iptables/IPVS) 규칙으로 구현되는 논리적(가상) IP 상세 정리

> 주제: **Kubernetes Service의 가상(논리) IP(특히 ClusterIP)가 kube-proxy의 iptables 또는 IPVS 규칙으로 어떻게 “실제처럼” 동작하는가**

---

## 1) “가상(논리) IP”란?

Kubernetes에서 Service를 만들면 보통 아래와 같은 IP/진입점이 생깁니다.

- **ClusterIP**: `10.43.x.x` 같은 **클러스터 내부용 가상 IP**
- **NodePort**: 모든 노드의 `:3xxxx` 포트를 열어주는 “노드 단” 진입점
- (환경에 따라) **LoadBalancer External IP**, **Ingress VIP** 등

핵심은 다음입니다.

- **ClusterIP는 어떤 NIC(네트워크 인터페이스)에도 실제로 할당되지 않는 IP**입니다.
- 그런데도 `ClusterIP:Port`로 트래픽을 보내면 Pod로 연결되는 이유는,
  **kube-proxy가 커널 레벨 규칙(iptables/IPVS)을 설정해 “패킷을 다른 곳으로 바꿔치기”** 하기 때문입니다.

즉, ClusterIP는 “물리/실재 IP”가 아니라 **논리적으로만 존재하는 가상 IP**입니다.

---

## 2) kube-proxy의 역할 (한 줄 요약)

kube-proxy는 계속 Watch 하면서:

- **Service**(ClusterIP/Port)
- **EndpointSlice**(또는 Endpoints: 실제 Pod IP:Port 목록)

이 둘을 바탕으로 노드 커널에

- **iptables 규칙(NAT/필터 체인)** 또는
- **IPVS 가상 서버/리얼 서버 규칙**

을 구성해서 다음 동작을 구현합니다.

> `ServiceIP:ServicePort` → `PodIP:TargetPort` 로 트래픽을 분산/전달

---

## 3) iptables 모드: “NAT 규칙으로 가상 IP를 실현”

### 3-1. ClusterIP가 “살아있는 것처럼” 동작하는 이유

클러스터 내부에서 어떤 Pod가 `ClusterIP:Port`(예: `10.43.31.179:80`)로 접속하면:

1. 패킷이 노드의 네트워크 스택으로 들어옴
2. iptables의 **nat 테이블 PREROUTING/OUTPUT** 구간에서
3. kube-proxy가 만들어둔 규칙이 매칭되면
4. **DNAT** 발생  
   - 목적지(`dst`)가 `ClusterIP:80` → `선택된 PodIP:80` 으로 변경
5. 이후 라우팅은 “PodIP” 기준으로 진행되어 실제 Pod로 전달됨

즉, ClusterIP가 “실제로 존재해서 연결되는” 게 아니라  
**목적지 IP/포트를 바꿔치기(Destination NAT)해서 연결되는 것**입니다.

### 3-2. 로드밸런싱(분산)은 어떻게?

iptables는 “L4 로드밸런서” 자체는 아니므로 kube-proxy는 보통 다음 방식으로 분산합니다.

- 여러 Endpoint로 향하는 규칙을 만들어두고
- 새 연결이 들어올 때 확률 기반(statistic) 등으로 엔드포인트를 선택

그리고 한 번 연결이 성립되면(특히 TCP):

- 리눅스 **conntrack(연결 추적)** 이 해당 흐름을 기억해
- 같은 커넥션의 패킷은 같은 Pod로 계속 전달됩니다.

> 정리: **새 연결 시점에만** 엔드포인트를 고르고, 이후는 conntrack이 유지합니다.

---

## 4) IPVS 모드: “커널 내 L4 로드밸런서로 구현”

IPVS 모드는 개념적으로 “정통 L4 LB”에 가깝습니다.

- **Virtual Server**: `ClusterIP:Port` 를 가상 서버로 등록
- **Real Server**: 실제 PodIP:Port들을 리얼 서버로 등록
- 스케줄링 알고리즘도 사용 가능  
  (예: rr(라운드로빈), lc(least-conn) 등)

패킷이 `ClusterIP:80`으로 들어오면,

- 커널의 IPVS가 리얼 서버(Pod)를 선택해 전달합니다.

> iptables 모드: 규칙 집합 기반 NAT 분산  
> IPVS 모드: 커널이 제공하는 L4 LB 기능 활용


## 6) “왜 가상 IP라고 부르나?” (핵심 결론)

ClusterIP는 라우터나 NIC가 가진 실제 IP가 아닙니다.

- **커널 규칙이 “그 IP로 온 패킷을 가로채서 다른 IP(PodIP)로 바꾸는 방식”**으로만 존재합니다.

따라서 네트워크 관점에서 ClusterIP는:

- **존재하지 않는 IP를 존재하는 것처럼 보이게 만드는**
- **논리적(가상) IP**

입니다.

---

## 7) 트래픽 흐름 예시(ClusterIP 기준)

예: `web-svc`  
- ClusterIP: `10.43.31.179`
- Service Port: `80`
- Endpoints: `10.42.1.8:80`, `10.42.2.4:80`

Pod A가 `http://10.43.31.179:80`으로 접속할 때:

1. Pod A에서 `dst=10.43.31.179:80`으로 패킷 생성
2. 노드 커널로 들어옴
3. nat OUTPUT/PREROUTING에서 “10.43.31.179:80” 규칙 매칭
4. kube-proxy 규칙이 Endpoint 하나 선택
5. DNAT: 목적지 → `10.42.1.8:80` (예시)
6. 라우팅: CNI/overlay를 통해 해당 Pod로 전달
7. 응답: conntrack에 의해 흐름이 유지되며 왕복 성립

---

## (선택) 실습에서 눈으로 확인하고 싶다면

- iptables 규칙 확인(iptables 모드)
  - `iptables -t nat -S | grep KUBE-`
- IPVS 테이블 확인(IPVS 모드)
  - `ipvsadm -Ln`
- conntrack 확인(연결 고정/추적)
  - `conntrack -L`

> k3s 환경이라면 구성(iptables/IPVS)과 CNI 방식에 따라 출력 형태가 조금 달라질 수 있습니다.


---

## 2. 사용자 환경 출력으로 “실제 값” 매핑하기

아래 값들은 **cp1 노드 기준**이며, 사용자가 제공한 출력에서 그대로 가져왔습니다.

---

## 3. 노드(서버/VM) 관점: Node IP & Internal IP

### 3.1 `kubectl get nodes -o wide` (Internal IP 확인)
```
NAME   STATUS   ROLES           AGE   VERSION        INTERNAL-IP     EXTERNAL-IP
cp1    Ready    control-plane   21d   v1.34.3+k3s1   192.168.56.10   <none>
w1     Ready    <none>          21d   v1.34.3+k3s1   192.168.56.11   <none>
w2     Ready    <none>          21d   v1.34.3+k3s1   192.168.56.12   <none>
```

- cp1 Internal IP: **192.168.56.10**
- w1 Internal IP: **192.168.56.11**
- w2 Internal IP: **192.168.56.12**
- `EXTERNAL-IP`는 `<none>` → 공인 IP(클라우드 Public IP) 같은 것이 붙어 있지 않은 실습 구성

✅ 결론  
- 이 환경에서 Kubernetes가 노드 대표 주소로 쓰는 Internal IP는 **192.168.56.0/24 대역**입니다.

---

### 3.2 `ip -br a` (노드에 실제로 붙은 IP 확인)
```
enp0s3  UP  10.0.2.15/24 ...
enp0s8  UP  192.168.56.10/24 ...
```

- `enp0s8: 192.168.56.10/24`  
  - 실습에서 흔한 **VirtualBox Host-Only** 대역  
  - Kubernetes가 `INTERNAL-IP`로 선택한 값

- `enp0s3: 10.0.2.15/24`  
  - VirtualBox 기본 **NAT** 대역인 경우가 많음  
  - “인터넷(외부)로 나갈 때” 기본 경로로 쓰이는 NIC

✅ 결론  
- 노드(cp1)는 실제로 IP가 2개(= Node IP가 2개)이고,  
  Kubernetes Internal IP는 그중 **192.168.56.10(enp0s8)** 쪽으로 잡혀 있습니다.

---

### 3.3 `ip route` (기본 게이트웨이/라우팅 확인)
```
default via 10.0.2.2 dev enp0s3 src 10.0.2.15
192.168.56.0/24 dev enp0s8 src 192.168.56.10
```

- `default via 10.0.2.2 dev enp0s3`  
  → cp1이 외부로 나갈 때 기본 경로는 **enp0s3(NAT)**

- `192.168.56.0/24 dev enp0s8`  
  → 노드 간 통신(Host-Only)은 **enp0s8**로 직접 연결

✅ 결론  
- **클러스터 내부(노드 간) 대표 IP = 192.168.56.x**
- **외부로 나가는 기본 길 = 10.0.2.x (NAT)**

---

## 4. Pod 네트워크 관점: Pod IP (10.42.x.x)

`ip -br a` / `ip route`에서 다음이 보였습니다.

### 4.1 인터페이스
- `cni0: 10.42.0.1/24`
- `flannel.1: 10.42.0.0/32`

### 4.2 라우팅
```
10.42.0.0/24 dev cni0 src 10.42.0.1
10.42.1.0/24 via 10.42.1.0 dev flannel.1 onlink
10.42.2.0/24 via 10.42.2.0 dev flannel.1 onlink
```

✅ 해석
- **10.42.x.x**는 Pod 네트워크 대역(Pod IP)
- 보통 노드별로 /24씩 쪼개어 할당되는 패턴이 많습니다.
  - cp1 노드: 10.42.0.0/24
  - w1 노드: 10.42.1.0/24
  - w2 노드: 10.42.2.0/24
- 노드 간 Pod 통신은 `flannel.1` 같은 오버레이 인터페이스를 통해 라우팅됩니다.

---
---
### 데모 web-svc 추가 - 이미 있다면 이미 있음 오류 무시
```
ubuntu@cp1:~$ kubectl create namespace demo
Error from server (AlreadyExists): namespaces "demo" already exists
```

```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web
  namespace: demo
  labels:
    app: web
spec:
  replicas: 2
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      containers:
        - name: nginx
          image: nginx:1.27-alpine
---
apiVersion: v1
kind: Service
metadata:
  name: web-svc
  namespace: demo
spec:
  selector:
    app: web
  ports:
    - port: 80
      targetPort: 80
  type: ClusterIP
```
---
```
ubuntu@cp1:~$ kubectl apply -f web.yaml
Warning: resource deployments/web is missing the kubectl.kubernetes.io/last-applied-configuration annotation which is required by kubectl apply. kubectl apply should only be used on resources created declaratively by either kubectl create --save-config or kubectl apply. The missing annotation will be patched automatically.
deployment.apps/web configured
service/web-svc configured
```
---
```
ubuntu@cp1:~$ kubectl -n demo get deploy,pod,svc -o wide
kubectl -n demo describe deploy web | sed -n '1,120p'
NAME                  READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES              SELECTOR
deployment.apps/web   2/2     2            2           26h   nginx        nginx:1.27-alpine   app=web

NAME                       READY   STATUS    RESTARTS   AGE   IP           NODE   NOMINATED NODE   READINESS GATES
pod/web-79ffc79c64-7lczb   1/1     Running   0          70s   10.42.2.14   w2     <none>           <none>
pod/web-79ffc79c64-wgc5c   1/1     Running   0          26h   10.42.1.8    w1     <none>           <none>

NAME              TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE   SELECTOR
service/web-svc   ClusterIP   10.43.31.179   <none>        80/TCP    26h   app=web
Name:                   web
Namespace:              demo
CreationTimestamp:      Sat, 24 Jan 2026 06:49:08 +0000
Labels:                 app=web
Annotations:            deployment.kubernetes.io/revision: 1
Selector:               app=web
Replicas:               2 desired | 2 updated | 2 total | 2 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=web
  Containers:
   nginx:
    Image:         nginx:1.27-alpine
    Port:          <none>
    Host Port:     <none>
    Environment:   <none>
    Mounts:        <none>
  Volumes:         <none>
  Node-Selectors:  <none>
  Tolerations:     <none>
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Progressing    True    NewReplicaSetAvailable
  Available      True    MinimumReplicasAvailable
OldReplicaSets:  <none>
NewReplicaSet:   web-79ffc79c64 (2/2 replicas created)
Events:
  Type    Reason             Age   From                   Message
  ----    ------             ----  ----                   -------
  Normal  ScalingReplicaSet  71s   deployment-controller  Scaled up replica set web-79ffc79c64 from 1 to 2

```


## 5. Service 관점: ClusterIP (10.43.x.x)

사용자가 제공한 `kubectl get svc -A -o wide` 출력:

```
default   kubernetes                 ClusterIP    10.43.0.1
default   my-helloworld-rs-service   NodePort     10.43.45.254   80:31885/TCP
demo      web-svc                    ClusterIP    10.43.31.179   80/TCP
kube-system kube-dns                 ClusterIP    10.43.0.10     53/UDP,53/TCP,...
kube-system traefik                  LoadBalancer 10.43.121.230  ... 80:31300,443:31309
...
```

✅ 결론
- 이 k3s 환경의 Service ClusterIP 대역은 **10.43.x.x**
- ClusterIP는 “서비스 VIP”이므로:
  - 노드 NIC에 IP로 붙지 않고
  - 보통 `ip a` 출력에 직접 보이지 않는 것이 정상입니다.

---

## 6. NodePort / LoadBalancer 서비스의 “외부 접근” 포인트

### 6.1 NodePort 예시: `my-helloworld-rs-service`
- TYPE: **NodePort**
- CLUSTER-IP: **10.43.45.254**
- PORT(S): **80:31885/TCP**

`80:31885` 의미
- 서비스 포트(Service Port): **80**
- 노드에서 열리는 포트(NodePort): **31885**

외부(내 PC)에서 접근 예시
- `http://192.168.56.10:31885` (cp1)
- `http://192.168.56.11:31885` (w1)
- `http://192.168.56.12:31885` (w2)

> NodePort는 기본적으로 “모든 노드에 포트가 열리고”, kube-proxy가 실제 Pod로 트래픽을 전달합니다.

---

### 6.2 LoadBalancer 예시: `kube-system/traefik`
- TYPE: **LoadBalancer**
- CLUSTER-IP: **10.43.121.230**
- EXTERNAL-IP: **192.168.56.10,192.168.56.11,192.168.56.12**
- PORT(S): **80:31300/TCP, 443:31309/TCP**

해석 포인트
- 클라우드(AWS ELB 등)처럼 “진짜 LB 장비 IP”가 생긴 것이 아니라,
  실습 환경에서는 `EXTERNAL-IP`가 **노드 IP들**로 보이는 형태가 흔합니다.
- 실제 접근은 다음처럼 NodePort 포트로 들어가는 형태로 보입니다.
  - `http://192.168.56.10:31300`
  - `https://192.168.56.10:31309`
  - (다른 노드 IP도 동일)

---

## 7. 한 장 요약(현재 환경 기준)

- **노드 Internal IP(= k8s가 쓰는 노드 대표 IP)**
  - cp1: **192.168.56.10**
  - w1: **192.168.56.11**
  - w2: **192.168.56.12**

- **노드 NAT IP(인터넷 나갈 때 주 경로)**
  - cp1: **10.0.2.15** (default route가 enp0s3로 잡힘)

- **Pod IP 대역**
  - **10.42.x.x** (cni0 / flannel 기반 라우팅)

- **Service ClusterIP 대역**
  - **10.43.x.x** (`kubectl get svc`의 CLUSTER-IP)

---

## 8. 통신 흐름 예시

### 8.1 클러스터 내부 (Pod → Service)
- Pod → `web-svc`(DNS) 또는 `10.43.31.179:80`
- kube-proxy 규칙(iptables/ipvs) → 실제 Pod들(10.42.x.x)로 전달

### 8.2 클러스터 외부 (내 PC → NodePort)
- 내 PC → `192.168.56.10:31885`
- NodePort → (내부적으로) Service/Endpoints → Pod(10.42.x.x)

---

## 9. 추가로 자주 쓰는 확인 명령

```bash
# 노드 대표 IP / 역할 확인
kubectl get nodes -o wide

# 서비스 ClusterIP / NodePort / LoadBalancer 확인
kubectl get svc -A -o wide

# 특정 서비스가 어떤 Pod로 연결되는지(실제 엔드포인트 확인)
kubectl get endpoints -n <ns> <svc-name> -o wide
kubectl describe svc -n <ns> <svc-name>

# Pod IP가 실제로 어떻게 잡혔는지 확인
kubectl get pods -A -o wide
```

---

## 10. 결론(질문에 대한 최종 답)

- **Node IP**: 노드(서버/VM)에 실제로 붙은 IP(여러 개일 수 있음).  
  - cp1 예: `10.0.2.15(enp0s3)`, `192.168.56.10(enp0s8)`

- **Internal IP**: Kubernetes가 노드를 대표로 식별/통신하기 위해 사용하는 노드 IP.  
  - cp1/w1/w2: `192.168.56.10/11/12`

- **ClusterIP**: Service에 할당되는 클러스터 내부 전용 VIP(가상 IP).  
  - 예: `10.43.31.179(web-svc)`, `10.43.45.254(my-helloworld-rs-service)` 등


### 예시
```
ubuntu@cp1:~$ kubectl get nodes -o wide
ip -br a
ip route
NAME   STATUS   ROLES           AGE   VERSION        INTERNAL-IP     EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION       CONTAINER-RUNTIME
cp1    Ready    control-plane   21d   v1.34.3+k3s1   192.168.56.10   <none>        Ubuntu 22.04.5 LTS   5.15.0-164-generic   containerd://2.1.5-k3s1
w1     Ready    <none>          21d   v1.34.3+k3s1   192.168.56.11   <none>        Ubuntu 22.04.5 LTS   5.15.0-164-generic   containerd://2.1.5-k3s1
w2     Ready    <none>          21d   v1.34.3+k3s1   192.168.56.12   <none>        Ubuntu 22.04.5 LTS   5.15.0-164-generic   containerd://2.1.5-k3s1
lo               UNKNOWN        127.0.0.1/8 ::1/128
enp0s3           UP             10.0.2.15/24 metric 100 fd17:625c:f037:2:a00:27ff:fe37:bfeb/64 fe80::a00:27ff:fe37:bfeb/64
enp0s8           UP             192.168.56.10/24 fe80::a00:27ff:fecf:7117/64
flannel.1        UNKNOWN        10.42.0.0/32 fe80::681b:72ff:fea5:9ba8/64
cni0             UP             10.42.0.1/24 fe80::ccd7:19ff:fe13:16d2/64
veth675a5d1b@if2 UP             fe80::c839:f4ff:fe16:8158/64
vethee10f9e1@if2 UP             fe80::1009:24ff:fe69:a22e/64
veth91827fd9@if2 UP             fe80::d44e:d5ff:fee3:1fb3/64
veth6d347fc0@if2 UP             fe80::9416:83ff:fefe:62c1/64
vetha7e3eebb@if2 UP             fe80::f4a4:82ff:fe7e:3cc/64
veth01f551b6@if2 UP             fe80::a4ad:22ff:fe8d:9ddd/64
vethefd14248@if2 UP             fe80::f028:96ff:feac:8c6d/64
veth2cdf935d@if2 UP             fe80::474:a9ff:fe2f:ad2/64
veth509c9e6b@if2 UP             fe80::84e5:97ff:fe23:ebc1/64
veth52e1df60@if2 UP             fe80::9866:5fff:fe0d:e1b8/64
veth5e7fe53f@if2 UP             fe80::4de:2cff:fecd:576c/64
veth5ae33433@if2 UP             fe80::546f:6cff:fe1f:198a/64
veth4cf47cf6@if2 UP             fe80::8c46:edff:fe34:35b0/64
vethb0320466@if2 UP             fe80::4064:c6ff:fe21:3e0c/64
veth18aeb522@if2 UP             fe80::cc3:e7ff:febd:2b7/64
veth406296eb@if2 UP             fe80::3c2e:f0ff:fe64:6b47/64
veth1c22cfe9@if2 UP             fe80::d401:d5ff:fe46:755c/64
veth5db60446@if2 UP             fe80::58db:d4ff:fe28:d380/64
vethd36a4227@if2 UP             fe80::58c4:2eff:fece:f442/64
default via 10.0.2.2 dev enp0s3 proto dhcp src 10.0.2.15 metric 100
10.0.2.0/24 dev enp0s3 proto kernel scope link src 10.0.2.15 metric 100
10.0.2.2 dev enp0s3 proto dhcp scope link src 10.0.2.15 metric 100
10.42.0.0/24 dev cni0 proto kernel scope link src 10.42.0.1
10.42.1.0/24 via 10.42.1.0 dev flannel.1 onlink
10.42.2.0/24 via 10.42.2.0 dev flannel.1 onlink
164.124.101.2 via 10.0.2.2 dev enp0s3 proto dhcp src 10.0.2.15 metric 100
192.168.56.0/24 dev enp0s8 proto kernel scope link src 192.168.56.10
203.248.252.2 via 10.0.2.2 dev enp0s3 proto dhcp src 10.0.2.15 metric 100
```
---
```
1) Node Internal IP = 192.168.56.10 (노드가 클러스터에서 쓰는 대표 IP)

kubectl get nodes -o wide에서:

cp1 INTERNAL-IP: 192.168.56.10

w1 INTERNAL-IP: 192.168.56.11

w2 INTERNAL-IP: 192.168.56.12

이게 **Kubernetes 입장에서 “노드 주소”**입니다.
실습 환경에선 보통 VirtualBox Host-Only(또는 내부망) NIC에 붙은 IP가 여기로 잡혀요.

✅ 특징

노드 간 통신/클러스터 운영에 사용

NodePort로 외부에서 들어올 때도 흔히 이 IP를 씀 (예: http://192.168.56.10:nodePort)

2) ip -br a에 보이는 2개의 “노드 IP”의 성격 차이

네 cp1에는 NIC가 2개라서 노드 IP가 2개가 있습니다.

(1) enp0s8 192.168.56.10/24

Host-Only 쪽 IP (너의 노드 INTERNAL-IP로 채택된 것)

클러스터 노드들이 서로 붙어있는 “실습용 내부망” 역할

(2) enp0s3 10.0.2.15/24

NAT 쪽 IP

ip route에서 default via 10.0.2.2 dev enp0s3 라고 나오는 것처럼,
인터넷(외부) 나갈 때 기본 게이트웨이로 쓰는 경로

✅ 요약하면:

클러스터 내부 통신 대표 = 192.168.56.10 (enp0s8)

바깥으로 나가는 길 = 10.0.2.15 (enp0s3, NAT)

3) Pod IP 대역 = 10.42.x.x (파드들이 쓰는 내부 IP)

출력에서:

cni0 UP 10.42.0.1/24

flannel.1 ... 10.42.0.0/32

라우팅에 10.42.1.0/24, 10.42.2.0/24가 flannel.1 통해 잡힘

이게 Pod 네트워크(오버레이) 대역입니다.

✅ 의미

cp1 노드 위의 파드는 주로 10.42.0.0/24

w1 노드 위의 파드는 주로 10.42.1.0/24

w2 노드 위의 파드는 주로 10.42.2.0/24

노드 간 Pod 통신은 flannel.1(VXLAN 같은 오버레이)로 라우팅

4) ClusterIP(서비스 IP)는 여기 출력엔 “안 보임” (Service 목록에서 봐야 함)

너가 붙여준 출력은 kubectl get nodes, ip a, ip route라서 Service의 ClusterIP(보통 10.43.x.x) 는 안 나옵니다.

ClusterIP는 이렇게 확인합니다:

kubectl get svc -A -o wide


여기서 CLUSTER-IP 컬럼에 10.43.x.x 같은 게 뜨면 그게 클러스터 내부 전용 VIP입니다.

왜 ip a/ip route에 안 보이냐?
ClusterIP는 노드에 “인터페이스로 붙는 IP”가 아니라, kube-proxy가 만든 iptables/ipvs 규칙으로 구현되는 가상 IP라서 보통 NIC 목록에 안 떠요.

한 눈에 정리 (너 출력 기준)

Internal IP(노드 대표 IP): 192.168.56.10 (cp1), 192.168.56.11 (w1), 192.168.56.12 (w2)

다른 노드 IP(외부로 나가는 NAT): 10.0.2.15 (cp1 enp0s3)

Pod IP 대역: 10.42.0.0/24(cp1), 10.42.1.0/24(w1), 10.42.2.0/24(w2)

ClusterIP(서비스 VIP): kubectl get svc -A -o wide에서 보이는 CLUSTER-IP (대개 10.43.x.x)
```
---
---
```
ubuntu@cp1:~$ kubectl get svc -A -o wide
NAMESPACE              NAME                                   TYPE           CLUSTER-IP      EXTERNAL-IP                                 PORT(S)                      AGE     SELECTOR
default                kubernetes                             ClusterIP      10.43.0.1       <none>                                      443/TCP                      21d     <none>
default                my-helloworld-rs-service               NodePort       10.43.45.254    <none>                                      80:31885/TCP                 96m     app=my-helloworld
default                whoami                                 ClusterIP      10.43.69.242    <none>                                      80/TCP                       21d     app=whoami
demo-hpa               nginx-svc                              ClusterIP      10.43.174.216   <none>                                      80/TCP                       14d     app=nginx
demo                   web-svc                                ClusterIP      10.43.31.179    <none>                                      80/TCP                       5h57m   app=web
kube-system            kube-dns                               ClusterIP      10.43.0.10      <none>                                      53/UDP,53/TCP,9153/TCP       21d     k8s-app=kube-dns
kube-system            metrics-server                         ClusterIP      10.43.49.227    <none>                                      443/TCP                      21d     k8s-app=metrics-server
kube-system            traefik                                LoadBalancer   10.43.121.230   192.168.56.10,192.168.56.11,192.168.56.12   80:31300/TCP,443:31309/TCP   21d     app.kubernetes.io/instance=traefik-kube-system,app.kubernetes.io/name=traefik
kubernetes-dashboard   kubernetes-dashboard-api               ClusterIP      10.43.110.114   <none>                                      8000/TCP                     20d     app.kubernetes.io/instance=kubernetes-dashboard,app.kubernetes.io/name=kubernetes-dashboard-api,app.kubernetes.io/part-of=kubernetes-dashboard
kubernetes-dashboard   kubernetes-dashboard-auth              ClusterIP      10.43.70.251    <none>                                      8000/TCP                     20d     app.kubernetes.io/instance=kubernetes-dashboard,app.kubernetes.io/name=kubernetes-dashboard-auth,app.kubernetes.io/part-of=kubernetes-dashboard
kubernetes-dashboard   kubernetes-dashboard-kong-proxy        ClusterIP      10.43.21.190    <none>                                      443/TCP                      20d     app.kubernetes.io/component=app,app.kubernetes.io/instance=kubernetes-dashboard,app.kubernetes.io/name=kong
kubernetes-dashboard   kubernetes-dashboard-metrics-scraper   ClusterIP      10.43.170.27    <none>                                      8000/TCP                     20d     app.kubernetes.io/instance=kubernetes-dashboard,app.kubernetes.io/name=kubernetes-dashboard-metrics-scraper,app.kubernetes.io/part-of=kubernetes-dashboard
kubernetes-dashboard   kubernetes-dashboard-web               ClusterIP      10.43.122.190   <none>                                      8000/TCP                     20d     app.kubernetes.io/instance=kubernetes-dashboard,app.kubernetes.io/name=kubernetes-dashboard-web,app.kubernetes.io/part-of=kubernetes-dashboard
```
---
```
1) ClusterIP = 10.43.x.x (Service가 가진 “클러스터 내부 전용 VIP”)

너 출력에서 CLUSTER-IP 컬럼이 전부 10.43.. 대역이죠.

예)

default/kubernetes → 10.43.0.1:443 (API Server 앞의 기본 서비스)

demo/web-svc → 10.43.31.179:80

kube-system/kube-dns → 10.43.0.10:53

demo-hpa/nginx-svc → 10.43.174.216:80

✅ 의미

Pod들이 “서비스 이름/DNS 또는 10.43.x.x”로 접속하면 트래픽이 해당 서비스의 Pod들로 로드밸런싱됨

이 IP는 노드 NIC에 붙은 IP가 아니라 가상 VIP라서 ip a에 보통 안 뜸

기본적으로 클러스터 밖(내 PC) 에서는 10.43.x.x로 직접 접근 못하는 게 정상

2) NodePort = “노드 IP(Internal IP)에 포트가 열리는 방식”

너 출력에 NodePort가 딱 하나 있네요:

default/my-helloworld-rs-service

TYPE: NodePort

CLUSTER-IP: 10.43.45.254

PORT(S): 80:31885/TCP

여기서 80:31885 의미:

서비스 포트(ClusterIP/서비스 내부): 80

노드에서 열리는 포트(NodePort): 31885

✅ 접근 방법 (클러스터 외부/내 PC에서)
노드 IP가 3개였죠:

cp1: 192.168.56.10

w1: 192.168.56.11

w2: 192.168.56.12

그래서 아래 어느 걸로 해도 들어갈 수 있습니다(노드가 살아있고 방화벽 없다는 가정):

http://192.168.56.10:31885

http://192.168.56.11:31885

http://192.168.56.12:31885

왜 워커로 접속해도 되나?
NodePort는 기본적으로 “모든 노드에 포트를 열고” kube-proxy가 실제 Pod로 보내주기 때문입니다.

3) LoadBalancer (k3s에서의 “특이 케이스”) = Traefik 서비스

너 출력에서:

kube-system/traefik

TYPE: LoadBalancer

CLUSTER-IP: 10.43.121.230

EXTERNAL-IP: 192.168.56.10,192.168.56.11,192.168.56.12

PORT(S): 80:31300, 443:31309

여기서 중요한 포인트:

(1) “EXTERNAL-IP가 노드 Internal IP들로 보임”

클라우드(AWS ELB 같은)처럼 진짜 로드밸런서 장비 IP가 생긴 게 아니라,
k3s 실습 환경에선 클러스터가 “외부 IP”라고 광고하는 값이 노드 IP로 잡혀 보일 수 있어요.

(2) 실제 외부 접근은 결국 NodePort 형태로도 같이 열려 있음

PORT(S)에 80:31300, 443:31309 라고 되어 있으니,
외부(내 PC)에서 접근은 이런 식으로 됩니다:

http://192.168.56.10:31300

https://192.168.56.10:31309
(다른 노드 IP로도 동일)

4) 네 환경을 한 장으로 “흐름” 정리
클러스터 내부 (Pod → Service)

Pod → web-svc(DNS) 또는 10.43.31.179:80
→ kube-proxy 규칙 → 실제 Pod들(10.42.x.x)로 전달

클러스터 외부 (내 PC → NodePort)

내 PC → 192.168.56.10:31885
→ NodePort → (내부에서) Service/Endpoints → Pod(10.42.x.x)

너가 지금 가진 IP들의 역할을 딱 찍어 말하면

192.168.56.10/11/12 = 노드 Internal IP(=NodePort로 외부에서 때리는 주소)

10.42.x.x = Pod IP(파드끼리 통신)

10.43.x.x = Service ClusterIP(서비스 VIP, 내부 전용)

10.0.2.15(cp1 enp0s3) = NAT 쪽 노드 IP(인터넷 나갈 때 주로 사용)

원하면, my-helloworld-rs-service가 실제 어떤 Pod로 연결되는지까지 “실제 엔드포인트(10.42.x.x)”를 찍어서 완성해볼까요? 아래만 치면 됩니다:

kubectl describe svc my-helloworld-rs-service
```
```
ubuntu@cp1:~$ kubectl describe svc my-helloworld-rs-service
Name:                     my-helloworld-rs-service
Namespace:                default
Labels:                   app=my-helloworld
Annotations:              <none>
Selector:                 app=my-helloworld
Type:                     NodePort
IP Family Policy:         SingleStack
IP Families:              IPv4
IP:                       10.43.45.254
IPs:                      10.43.45.254
Port:                     <unset>  80/TCP
TargetPort:               8080/TCP
NodePort:                 <unset>  31885/TCP
Endpoints:                10.42.1.10:8080,10.42.0.24:8080,10.42.2.12:8080 + 3 more...
Session Affinity:         None
External Traffic Policy:  Cluster
Internal Traffic Policy:  Cluster
Events:                   <none>
```
---
```
kubectl get endpoints my-helloworld-rs-service -o wide
```
```
ubuntu@cp1:~$ kubectl get endpoints my-helloworld-rs-service -o wide
Warning: v1 Endpoints is deprecated in v1.33+; use discovery.k8s.io/v1 EndpointSlice
NAME                       ENDPOINTS                                                     AGE
my-helloworld-rs-service   10.42.0.23:8080,10.42.0.24:8080,10.42.1.10:8080 + 3 more...   21h
```
---
```
kubectl get pods -l app=my-helloworld -o wide
```
```
ubuntu@cp1:~$ kubectl get pods -l app=my-helloworld -o wide
NAME                     READY   STATUS    RESTARTS   AGE   IP           NODE   NOMINATED NODE   READINESS GATES
my-helloworld-rs-hdqsn   1/1     Running   0          25h   10.42.2.12   w2     <none>           <none>
my-helloworld-rs-jq8v2   1/1     Running   0          25h   10.42.2.11   w2     <none>           <none>
my-helloworld-rs-mn9cd   1/1     Running   0          25h   10.42.1.10   w1     <none>           <none>
my-helloworld-rs-qhbv4   1/1     Running   0          25h   10.42.0.23   cp1    <none>           <none>
my-helloworld-rs-shhpc   1/1     Running   0          25h   10.42.0.24   cp1    <none>           <none>
my-helloworld-rs-vswg5   1/1     Running   0          25h   10.42.1.9    w1     <none>           <none>
```