# kubectl + Linux 혼합 명령어 치트시트 (현장 패턴 정리)

> **핵심 요약**
- `kubectl ...`로 시작하면 **Kubernetes API(클러스터 리소스)**를 조회/조작하는 흐름이 시작됩니다.
- `kubectl exec POD -- <cmd>`에서 `--` **뒤의 `<cmd>`는 Linux 명령이지만 “컨테이너(파드) 내부”**에서 실행됩니다.
- `| grep/awk/sed/sort/head/tail`, `$()`, 변수(`POD=...`)가 보이면 **Linux 쉘이 kubectl 출력(텍스트)을 가공** 중입니다.

---

## 1) “대상(리소스)”로 먼저 구분하기

### A. Linux 명령어(호스트/로컬 OS 대상)
`ls`, `cd`, `grep`, `awk`, `sed`, `tail`, `journalctl`, `systemctl`, `ps`, `curl`, `ssh` ...
- **내 PC/서버(호스트 OS)**의 파일/프로세스/서비스를 다룸

### B. Kubernetes 명령어(k8s API 대상)
`kubectl get/describe/logs/exec/apply/delete/top ...`
- **클러스터 리소스(Pod/Service/Deployment/Node 등)**를 다룸  
- `kubectl`은 결국 **API Server에 요청**을 보냅니다.

### C. 컨테이너 안(Linux이지만 Pod 내부) 대상
예: `kubectl exec POD -- ls /var/log`
- `exec` 뒤의 명령은 **Pod 내부 Linux**
- 헷갈리기 쉬운 포인트: **명령은 Linux인데, 실행 “대상”이 Pod 내부**

---

## 2) 가장 흔한 혼합 패턴: “kubectl 출력”을 Linux 파이프로 가공

### 예시 A) Running Pod만 보기
```bash
kubectl get pods -n demo | grep Running
```
- **k8s:** `kubectl get pods -n demo`
- **Linux:** `| grep Running`
- 의미: k8s에서 목록을 가져오고 → Linux 도구로 텍스트 필터링

### 예시 B) 특정 컬럼만 뽑기
```bash
kubectl get pods -n demo -o wide | awk '{print $1, $6, $7}'
```
- **k8s:** `kubectl get ...`
- **Linux:** `awk ...`
- 의미: “가져오기(k8s)” + “가공(Linux 텍스트 처리)”

> **팁:** 가능하면 `-o jsonpath=...` / `-o go-template=...`처럼 **kubectl 출력 옵션으로 구조적으로 뽑는 방식이 더 안전**합니다.

---

## 3) “호스트 Linux” vs “Pod 내부 Linux” 섞어 쓰기

### 예시 C) 호스트에서 실행(내 서버)
```bash
tail -n 50 /var/log/syslog
```
- **전부 Linux(호스트)**

### 예시 D) Pod 안에서 실행(컨테이너 내부 Linux)
```bash
kubectl exec -n demo mypod -- tail -n 50 /var/log/nginx/access.log
```
- **k8s:** `kubectl exec -n demo mypod --`
- **Linux(컨테이너 내부):** `tail -n 50 ...`

> **구분 포인트:** `kubectl exec POD --` 뒤는 Linux 명령이지만 **호스트가 아니라 Pod 내부**에서 실행됩니다.

---

## 4) “kubectl 결과를 변수로 받아” Linux 흐름에서 재사용

### 예시 E) 첫 번째 Pod 이름을 가져와서 로그 보기
```bash
POD=$(kubectl get pods -n demo -l app=nginx -o jsonpath='{.items[0].metadata.name}')
kubectl logs -n demo "$POD" | tail -n 50
```
- **Linux:** `POD=$( ... )` (쉘 변수/커맨드 치환)
- **k8s:** `kubectl get ...`
- **k8s:** `kubectl logs ...`
- **Linux:** `| tail -n 50`

---

## 5) “리소스 상태 파악 + 원인 분석” 혼합 대표 흐름

### 예시 F) CrashLoopBackOff Pod 찾고, 이벤트/로그 확인
```bash
kubectl get pods -n demo | egrep 'CrashLoopBackOff|Error'
kubectl describe pod -n demo <pod-name> | less
kubectl logs -n demo <pod-name> --previous | tail -n 100
```
- **k8s:** `kubectl get/describe/logs`
- **Linux:** `egrep`, `less`, `tail`
- 의미: k8s 정보 수집 후 → Linux 도구로 읽기/검색/요약

---

## 6) Node(리눅스) 문제와 Pod 문제를 같이 볼 때

### 예시 G) Node 상태 확인(k8s) + 노드 OS 로그 보기(Linux)
```bash
kubectl get nodes -o wide
kubectl describe node <node-name> | egrep 'Conditions|Ready|Pressure'
ssh <node-ip> "sudo journalctl -u kubelet -n 200 --no-pager"
```
- **k8s:** `kubectl get/describe`
- **Linux:** `egrep`
- **Linux(노드 OS):** `ssh ... journalctl ...`
- 의미: “클러스터 관점(k8s)”과 “노드 OS 관점(Linux)”을 교차 확인

---

## 7) 헷갈림 방지용 3줄 규칙

1. `kubectl`이 앞에 오면 **k8s 리소스 조회/조작**이 시작된다.  
2. `--` 뒤에 오는 명령은 **컨테이너 내부 Linux 명령**이다.  
3. `|`, `grep/awk/sed`, `$()`가 보이면 **Linux 쉘이 kubectl 출력(텍스트)을 가공** 중이다.

---

# 작업 흐름별 “혼합 명령어 세트” (Cheat Sheet)

아래는 현장에서 특히 많이 쓰는 4개 시나리오를 기준으로, **kubectl(K8s) + Linux(쉘/텍스트/네트워크)**가 섞인 형태로 정리했습니다.

---

## 1) Pod 장애 분석 (CrashLoop, ImagePull, OOM, Pending 등)

### 1-1. 이상 Pod 빠르게 찾기
```bash
kubectl get pod -A | egrep 'CrashLoopBackOff|Error|ImagePullBackOff|Pending|Evicted'
```
- **k8s:** `kubectl get pod -A`
- **Linux:** `egrep ...`

### 1-2. 이벤트/원인(스케줄링, 이미지, 볼륨 등) 확인
```bash
kubectl describe pod -n demo mypod | egrep -n 'Events|Warning|Failed|Back-off|OOM|Pull'
```
- **k8s:** `describe`
- **Linux:** `egrep -n`

### 1-3. 로그 확인(현재/이전 컨테이너)
```bash
kubectl logs -n demo mypod --tail=200
kubectl logs -n demo mypod --previous --tail=200 | tail -n 50
```
- **k8s:** `logs`
- **Linux:** `tail`(후처리)

### 1-4. Pod 내부에서 프로세스/파일 확인(컨테이너 내부 Linux)
```bash
kubectl exec -n demo mypod -- sh -lc "ps aux | head"
kubectl exec -n demo mypod -- sh -lc "ls -al /app && df -h"
```
- **k8s:** `exec ... --`
- **Linux(컨테이너 내부):** `ps/ls/df/head`

### 1-5. 리소스/메모리 압박(OOM) 의심 시(top + 정렬)
```bash
kubectl top pod -n demo | sort -k3 -hr | head
```
- **k8s:** `top pod`
- **Linux:** `sort/head`

### 1-6. 노드 레벨 확인(노드 상태 + kubelet 로그)
```bash
kubectl get node -o wide
kubectl describe node <node> | egrep -n 'Ready|Pressure|Disk|Memory|PID|Events'
ssh <node-ip> "sudo journalctl -u kubelet -n 200 --no-pager | tail -n 80"
```
- **k8s:** node 조회/describe
- **Linux:** `egrep`, `ssh/journalctl/tail`

---

## 2) 서비스 라우팅 확인 (Service/Endpoints/DNS/NetworkPolicy 포함)

### 2-1. Service/Endpoints가 실제로 붙었는지
```bash
kubectl get svc,ep -n demo -o wide
kubectl get ep -n demo my-svc -o yaml | egrep -n 'subsets|addresses|ports'
```
- **k8s:** `get svc,ep`, `get ep -o yaml`
- **Linux:** `egrep`

> **Endpoints가 비어있으면** 높은 확률로 `selector ↔ pod label` 불일치입니다.

### 2-2. selector/label 매칭 검증
```bash
kubectl get svc -n demo my-svc -o jsonpath='{.spec.selector}'; echo
kubectl get pod -n demo --show-labels | grep app=
```
- **k8s:** `jsonpath` 출력, pod 조회
- **Linux:** `echo`, `grep`

### 2-3. 클러스터 내부에서 curl로 라우팅 테스트(임시 디버그 Pod)
```bash
kubectl run -n demo tmp --rm -it --image=curlimages/curl -- sh
# (Pod 안에서)
curl -sS http://my-svc:8080/health | head
```
- **k8s:** `kubectl run ...`
- **Linux(컨테이너 내부):** `sh/curl/head`

### 2-4. DNS 확인(CoreDNS)
```bash
kubectl run -n demo dns --rm -it --image=busybox:1.36 -- sh
# (Pod 안에서)
nslookup my-svc
nslookup my-svc.demo.svc.cluster.local
```
- **k8s:** `kubectl run ...`
- **Linux(컨테이너 내부):** `nslookup`

### 2-5. NetworkPolicy 의심 시(정책/적용 범위)
```bash
kubectl get netpol -A
kubectl describe netpol -n demo <name> | egrep -n 'podSelector|ingress|egress|policyTypes'
```
- **k8s:** `get/describe netpol`
- **Linux:** `egrep`

---

## 3) HPA/리소스 튜닝 (requests/limits, metrics, scale 동작 확인)

### 3-1. HPA 상태/이벤트 확인
```bash
kubectl get hpa -n demo
kubectl describe hpa -n demo my-hpa | egrep -n 'Metrics|Current|Target|Events|Failed'
```
- **k8s:** `get/describe hpa`
- **Linux:** `egrep`

### 3-2. Pod/Node 리소스 실측(top) + 정렬
```bash
kubectl top pod -n demo | sort -k3 -hr | head
kubectl top node | sort -k3 -hr | head
```
- **k8s:** `top`
- **Linux:** `sort/head`

### 3-3. requests/limits 확인(Deployment → Pod 템플릿)
```bash
kubectl get deploy -n demo myapp -o yaml | egrep -n 'resources:|requests:|limits:'
```
- **k8s:** `get deploy -o yaml`
- **Linux:** `egrep`

### 3-4. HPA가 안 움직일 때(대표 원인 점검)
#### (a) metrics-server 없음/오류
```bash
kubectl get deploy -n kube-system | grep metrics
kubectl logs -n kube-system deploy/metrics-server --tail=200 | egrep -i 'error|fail|x509|timeout'
```
- **k8s:** `get/logs`
- **Linux:** `grep/egrep`

#### (b) requests 미설정(특히 CPU 기반 HPA)
```bash
kubectl get pod -n demo -o jsonpath='{range .items[*]}{.metadata.name}{"	"}{.spec.containers[0].resources.requests.cpu}{"
"}{end}'
```
- **k8s:** `jsonpath`로 구조적으로 추출(가장 안전)

### 3-5. 부하를 줘서 스케일 테스트(임시 load generator)
```bash
kubectl run -n demo load --rm -it --image=busybox:1.36 -- sh -lc "while true; do wget -qO- http://my-svc:8080/ >/dev/null; done"
```
- **k8s:** `kubectl run ...`
- **Linux(컨테이너 내부):** `sh/while/wget`

---

## 4) Ingress/로드밸런서 확인 (Ingress Controller, LB, TLS, 라우팅)

### 4-1. Ingress 기본 확인
```bash
kubectl get ingress -A
kubectl describe ingress -n demo my-ing | egrep -n 'Rules|Host|Path|Backend|TLS|Events'
```
- **k8s:** ingress 조회/describe
- **Linux:** `egrep`

### 4-2. Ingress Controller 상태/로그(NGINX 기준)
```bash
kubectl get pod -n ingress-nginx -o wide
kubectl logs -n ingress-nginx deploy/ingress-nginx-controller --tail=200 | egrep -i 'error|warn|upstream|ssl|timeout'
```
- **k8s:** `get/logs`
- **Linux:** `egrep -i`

### 4-3. LoadBalancer EXTERNAL-IP 할당 여부
```bash
kubectl get svc -A | grep LoadBalancer
kubectl describe svc -n ingress-nginx ingress-nginx-controller | egrep -n 'Type:|LoadBalancer|EXTERNAL-IP|Events'
```
- **k8s:** svc 조회/describe
- **Linux:** `grep/egrep`

### 4-4. 실제 접속 테스트(curl) + Host 기반 라우팅
```bash
ING_IP=<external-ip-or-nodeip>
curl -i -H "Host: example.com" "http://$ING_IP/" | head -n 30
```
- **Linux:** `curl/head`

> Ingress는 **Host 헤더 기반 라우팅**이 흔합니다. 그래서 `-H "Host: ..."` 테스트가 중요합니다.

### 4-5. TLS/인증서(secret) 확인
```bash
kubectl get secret -n demo | grep tls
kubectl describe secret -n demo my-tls | egrep -n 'Type:|tls.crt|tls.key'
```
- **k8s:** secret 조회/describe
- **Linux:** `grep/egrep`

### 4-6. 경로 매칭 꼬임(우선순위/정규식/리라이트) 의심 시
```bash
kubectl get ingress -n demo my-ing -o yaml | egrep -n 'path:|pathType:|rewrite|annotation|backend'
```
- **k8s:** `get ... -o yaml`
- **Linux:** `egrep` (텍스트 탐색)

---

## 한 장 요약: “어디서 실행되는 Linux냐”가 핵심

- `kubectl ...` = **k8s API 대상으로 리소스 조작/조회**
- `| grep/awk/sed/sort/head/tail` = **내 쉘이 k8s 출력 텍스트를 가공**
- `kubectl exec POD -- <cmd>` = `<cmd>`는 **Linux지만 Pod 내부에서 실행**
