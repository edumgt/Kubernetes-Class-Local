# Kubernetes에서 Pod와 Node의 차이점

## node 실행 파악
```
ubuntu@cp1:~$ kubectl get nodes
NAME   STATUS   ROLES           AGE     VERSION
cp1    Ready    control-plane   6h2m    v1.34.3+k3s1
w1     Ready    <none>          5h50m   v1.34.3+k3s1
w2     Ready    <none>          5h47m   v1.34.3+k3s1
```
## Worker Node 실행 중지 후 다음 명령
### 노드가 죽어도 컨트롤플레인이 바로 NotReady로 바꾸지 않고, 일정 시간(헬스체크/하트비트 유예)을 보고 상태를 바꾸는 경우가 흔합니다. 그래서 -w로 보고 있어도 “몇십 초~수 분” 지연이 생길 수 있어요
---
```
ubuntu@cp1:~$ kubectl get nodes -w
NAME   STATUS     ROLES           AGE     VERSION
cp1    Ready      control-plane   6h3m    v1.34.3+k3s1
w1     NotReady   <none>          5h51m   v1.34.3+k3s1
w2     NotReady   <none>          5h48m   v1.34.3+k3s1
```


## 1. 기본 개념 비교

| 항목              | Pod                                              | Node (노드)                                          |
|-------------------|--------------------------------------------------|------------------------------------------------------|
| 개념              | Kubernetes의 **가장 작은 배포 단위**              | 클러스터를 구성하는 **실제 워커 머신** (물리/가상 서버) |
| 역할              | 하나 이상의 컨테이너를 실행하는 논리적 그룹        | Pod들을 실제로 실행·관리하는 물리적/가상 인프라         |
| 생성 주체         | 사용자 / Deployment / StatefulSet / Job 등        | 클러스터 관리자 또는 autoscaler가 서버를 추가할 때     |
| 수명 주기         | 매우 짧음 (삭제·재시작·스케일링 시 자주 생성/소멸) | 매우 길음 (서버가 살아있는 동안 지속)                  |
| IP 주소           | Pod마다 고유한 클러스터 내부 IP 할당              | Node 자체도 IP 있음 (Pod IP와 별개)                    |
| 스케줄링 대상     | Kubernetes 스케줄러가 적절한 Node에 배치           | 사람이 직접 추가하거나 kubelet 등록                   |
| 여러 개 실행 가능 | 하나의 Node 위에 **여러 개의 Pod** 동시 실행 가능 | 하나의 클러스터에 **여러 개의 Node** 존재 가능        |
| 장애 시 동작      | Pod 장애 → 컨트롤러가 자동으로 새 Pod 생성         | Node 장애 → 해당 Node의 모든 Pod가 다른 Node로 재배치  |
| 관리 관점         | **애플리케이션** 중심 (Deployment, ReplicaSet 등) | **인프라** 중심 (클러스터 autoscaler, 노드 유지보수)   |
| 대표 명령어       | `kubectl get pods`<br>`kubectl describe pod`     | `kubectl get nodes`<br>`kubectl describe node`        |

## 2. 핵심 차이점 요약 (가장 중요한 3가지)

1. **추상화 수준**  
   - **Pod** : 애플리케이션 레벨의 추상화  
     → 어떤 컨테이너들을 어떻게 같이 실행할 것인가  
   - **Node** : 인프라 레벨의 추상화  
     → 어떤 물리적/가상 서버에 Pod를 올릴 것인가

2. **생명 주기**  
   - **Pod** : 일시적이며 빈번하게 생성·소멸  
     (스케일링, 롤링 업데이트, 장애 복구 등 정상 운영 중에도 자주 발생)  
   - **Node** : 가능한 한 장기간 유지되어야 하는 서버  
     (하드웨어 교체, OS 업그레이드 등으로만 교체됨)

3. **계층 관계**
```
클러스터
├─ Node 1
│     ├─ Pod A (nginx + filebeat)
│     ├─ Pod B (backend-api)
│     └─ Pod C (redis)
├─ Node 2
│     ├─ Pod D (frontend)
│     └─ Pod E (worker)
└─ Node 3
└─ ...
```
text## 3. 실무적 비유
Node  = 건물 (데이터센터의 물리/가상 서버)
Pod   = 건물 안에 입주해 있는 세입자 (실행 중인 애플리케이션)
• 건물(Node)은 최대한 오래 안정적으로 유지·관리
• 세입자(Pod)는 이사(삭제), 새 입주(생성)가 매우 빈번함
text## 4. 실무에서 자주 비교되는 추가 항목

| 항목                        | Pod                                      | Node                                          |
|-----------------------------|------------------------------------------|-----------------------------------------------|
| 리소스 requests/limits      | 적용 (컨테이너 단위)                      | 적용 (kubelet이 Node 전체 리소스 관리)         |
| taints & tolerations        | tolerations 설정                         | taints 설정 (특정 Pod 배치 제한)              |
| node affinity / selector    | Pod에서 Node 선택 조건 설정               | Node 자체에 속성 부여                          |
| 장애 격리 범위              | Pod 단위 (다른 Pod 영향 최소)             | Node 단위 (같은 Node 내 모든 Pod 영향)        |
| autoscaling 대상            | HPA (Horizontal Pod Autoscaler)          | Cluster Autoscaler / Karpenter                |
| 모니터링 포커스             | 애플리케이션/컨테이너 메트릭               | OS, kubelet, 하드웨어, 컨테이너 런타임 메트릭   |

## 요약 (한 문장)

**Pod**는 애플리케이션 실행 단위를 나타내는 **논리적 개념**이며,  
**Node**는 그 Pod를 실제로 실행하는 **물리적/가상 인프라**입니다.

---

## 쿠버네티스 매니페스트(Manifest) 는 “클러스터에 적용할 리소스 정의서”이고, 보통 YAML 형식으로 작성합니다. 아래는 형식(필수 필드) 과 자주 쓰는 예시들입니다.

### 1) 매니페스트 기본 형식(공통 골격)
```
apiVersion: <리소스가 속한 API 버전>
kind: <리소스 종류>
metadata:
  name: <이름>
  namespace: <네임스페이스>   # 선택 (없으면 default)
  labels:                    # 선택
    app: myapp
spec:                        # 리소스별로 내용이 달라짐
  ...
```
---

```
apiVersion: 예) v1, apps/v1, autoscaling/v2

kind: 예) Pod, Deployment, Service, Ingress, ConfigMap, Secret

metadata.name: 리소스 이름(네임스페이스 내 유니크)

spec: “원하는 상태(Desired State)” 정의
```
---
### 2) 여러 리소스를 한 파일에 넣기 (--- 구분자)
```
apiVersion: v1
kind: Namespace
metadata:
  name: demo
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: demo-config
  namespace: demo
data:
  APP_MODE: "dev"
```
---

적용:
```
kubectl apply -f file.yaml
```
### 3) Pod 예시(가장 단순)
```
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
spec:
  containers:
  - name: nginx
    image: nginx:1.27-alpine
    ports:
    - containerPort: 80
```
---

### 4) Deployment 예시(실무 기본, Replica 관리)
```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
  namespace: demo
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.27-alpine
        ports:
        - containerPort: 80
        resources:
          requests:
            cpu: "50m"
            memory: "64Mi"
          limits:
            cpu: "300m"
            memory: "128Mi"
```
---

### 5) Service 예시(파드 앞단 고정 주소)
ClusterIP (클러스터 내부용, 기본)
```
apiVersion: v1
kind: Service
metadata:
  name: nginx-svc
  namespace: demo
spec:
  selector:
    app: nginx
  ports:
  - port: 80
    targetPort: 80

NodePort (노드 IP:포트로 외부 노출)
apiVersion: v1
kind: Service
metadata:
  name: nginx-nodeport
  namespace: demo
spec:
  type: NodePort
  selector:
    app: nginx
  ports:
  - port: 80
    targetPort: 80
    nodePort: 30080   # 보통 30000~32767
```
---

### 6) Ingress 예시(k3s 기본 Traefik과 함께 많이 씀)

k3s는 Traefik이 기본 Ingress Controller로 들어오는 경우가 많습니다.
```
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: nginx-ing
  namespace: demo
spec:
  rules:
  - host: nginx.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: nginx-svc
            port:
              number: 80
```
---

### 7) HPA 예시(오토스케일, CPU 기준)
```
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: nginx-hpa
  namespace: demo
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: nginx
  minReplicas: 2
  maxReplicas: 4
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 50
```
---
### 8) ConfigMap / Secret 예시
```
ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
  namespace: demo
data:
  APP_MODE: "prod"
  LOG_LEVEL: "info"

Secret (주의: base64 인코딩 필요)
apiVersion: v1
kind: Secret
metadata:
  name: db-secret
  namespace: demo
type: Opaque
data:
  username: dXNlcg==   # "user" base64
  password: cGFzcw==   # "pass" base64
```
---
### 9) 자주 쓰는 kubectl 명령
```
kubectl apply -f app.yaml
kubectl get all -n demo
kubectl describe deploy/nginx -n demo
kubectl logs -n demo deploy/nginx
kubectl delete -f app.yaml
```