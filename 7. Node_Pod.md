# Kubernetes에서 Pod와 Node의 차이점

## Node, Pod 의 상태 파악 도식화
### 1) Node/Pod 정보 게더링 전체 흐름(아키텍처)

```Mermaid
flowchart LR
  U["User / Operator<br/>kubectl · Dashboard · Scripts"] -->|GET/LIST/WATCH| APIS["Kube-API Server"]
  APIS --> ETCD[("etcd<br/>Cluster State Store")]

  subgraph NODE["Each Node"]
    K3S["k3s/k3s-agent<br/>(includes kubelet)"] -->|CRI| CRI["Container Runtime<br/>containerd/CRI-O"]
    K3S -->|CNI calls| CNI["CNI Plugin<br/>Cilium/Calico/Flannel..."]
    K3S -->|Mount/Attach| CSI["CSI Node Plugin<br/>(if used)"]
  end

  APIS -->|PodSpec / Desired State| K3S
  K3S -->|NodeStatus · PodStatus · Events| APIS

  subgraph METRICS["Metrics Path"]
    MS["metrics-server"] -->|serves| MAPI["Metrics API<br/>metrics.k8s.io"]
    K3S -->|resource summary| MS
    U -->|kubectl top| MAPI
  end

  subgraph OBS["Observability Stack"]
    PROM["Prometheus"] --> GRAF["Grafana"]
    KSM["kube-state-metrics"] --> PROM
    EXP["Node Exporter / app exporters"] --> PROM
    OTEL["OpenTelemetry Collector"] --> TRACE["Jaeger/Tempo"]
    LOGAG["Fluent Bit/Fluentd"] --> LOGS["Loki/ELK/OpenSearch"]
  end

  K3S -->|"/metrics (kubelet/cAdvisor) or exporters"| PROM
  APIS -->|"cluster objects"| KSM
  CRI -->|"container logs"| LOGAG
  U -->|"dashboards/alerts"| GRAF
```

![alt text](image-15.png)
![alt text](img001.png)

### 2) “게더링 → 분석” 운영 절차(플로우)
```Mermaid
flowchart TD
  S["Start: 이슈/요청 발생"] --> SCOPE["0) 범위/시간대 결정<br/>노드? 네임스페이스? 앱? 최근 1h? 배포 직후?"]
  SCOPE --> H1["1) 전반 상태 체크<br/>nodes/pods/events"]
  H1 -->|이상 없음| H2["추세/성능 문제 가능성<br/>Prometheus/Grafana로 이동"]
  H1 -->|이상 발견| CLASSIFY["2) 증상 분류"]

  CLASSIFY --> PENDING["A) Scheduling 문제<br/>Pending/Unschedulable"]
  CLASSIFY --> CRASH["B) Runtime 문제<br/>CrashLoop/OOM/ImagePull"]
  CLASSIFY --> NET["C) Network/DNS 문제<br/>Service/DNS/NetworkPolicy"]
  CLASSIFY --> RES["D) Resource 압박<br/>CPU/Mem/DiskPressure"]
  CLASSIFY --> AUTH["E) 권한/RBAC 문제<br/>Forbidden/Token/Auth"]

  PENDING --> NODES["3) 노드 드릴다운<br/>describe node · taint · resource"]
  RES --> NODES
  NODES --> NODELOG["노드 로그 확인<br/>k3s/k3s-agent journalctl"]
  NODELOG --> EVIDENCE["5) 근거 수집/시간축 정렬<br/>events+status+logs+metrics"]

  CRASH --> PODS["4) Pod 드릴다운<br/>describe pod · logs · probes"]
  NET --> PODS
  AUTH --> PODS
  PODS --> EVIDENCE

  H2 --> EVIDENCE

  EVIDENCE --> FIX["6) 조치<br/>롤백/설정수정/리소스조정/정책수정"]
  FIX --> VERIFY["검증<br/>상태 정상화 + 재발 모니터링"]
  VERIFY --> END["End: 런북/알람/대시보드 보완"]
```
![alt text](img002.png)

### 3) 다이어그램과 1:1로 매칭되는 “핵심 수집 명령” (붙여두면 편함)
#### (1) 전반 상태
```
kubectl get nodes -o wide
kubectl get pod -A -o wide
kubectl get events -A --sort-by=.lastTimestamp | tail -n 200
```
#### (2) 리소스(가능할 때: metrics-server 필요)
```
kubectl top nodes
kubectl top pod -A
```
#### (3) 특정 노드/파드 드릴다운
```
kubectl describe node <node>
kubectl describe node cp1
```
---
```
kubectl describe pod -n <ns> <pod>
kubectl describe pod -n default whoami-b85fc56b4-75gbn
```
---
```
ubuntu@cp1:~$ kubectl describe pod -n default whoami-b85fc56b4-75gbn
Name:             whoami-b85fc56b4-75gbn
Namespace:        default
Priority:         0
Service Account:  default
Node:             cp1/192.168.56.10
Start Time:       Thu, 22 Jan 2026 07:12:38 +0000
Labels:           app=whoami
                  pod-template-hash=b85fc56b4
Annotations:      <none>
Status:           Running
IP:               10.42.0.14
IPs:
  IP:           10.42.0.14
Controlled By:  ReplicaSet/whoami-b85fc56b4
Containers:
  whoami:
    Container ID:   containerd://034709103eb5a68e607543fa4088f5e890966b73b5455dd6b5e68e4436bd8c7b
    Image:          traefik/whoami
    Image ID:       docker.io/traefik/whoami@sha256:200689790a0a0ea48ca45992e0450bc26ccab5307375b41c84dfc4f2475937ab
    Port:           <none>
    Host Port:      <none>
    State:          Running
      Started:      Thu, 22 Jan 2026 07:12:47 +0000
    Ready:          True
    Restart Count:  0
    Environment:    <none>
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-4gzrj (ro)
Conditions:
  Type                        Status
  PodReadyToStartContainers   True
  Initialized                 True
  Ready                       True
  ContainersReady             True
  PodScheduled                True
Volumes:
  kube-api-access-4gzrj:
    Type:                    Projected (a volume that contains injected data from multiple sources)
    TokenExpirationSeconds:  3607
    ConfigMapName:           kube-root-ca.crt
    Optional:                false
    DownwardAPI:             true
QoS Class:                   BestEffort
Node-Selectors:              <none>
Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
                             node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  55m   default-scheduler  Successfully assigned default/whoami-b85fc56b4-75gbn to cp1
  Normal  Pulling    55m   kubelet            Pulling image "traefik/whoami"
  Normal  Pulled     55m   kubelet            Successfully pulled image "traefik/whoami" in 7.008s (7.008s including waiting). Image size: 3039655 bytes.
  Normal  Created    55m   kubelet            Created container: whoami
  Normal  Started    55m   kubelet            Started container whoami
```

---
```
kubectl logs -n <ns> <pod> --tail=300
kubectl logs -n <ns> <pod> --previous --tail=300
```

#### (4) k3s 노드 에이전트 로그(당신 케이스)
```
sudo journalctl -u k3s -n 200 --no-pager
```
워커면:
sudo journalctl -u k3s-agent -n 200 --no-pager
```

## node 실행 파악
```bash
ubuntu@cp1:~$ kubectl get nodes
NAME   STATUS   ROLES           AGE     VERSION
cp1    Ready    control-plane   6h2m    v1.34.3+k3s1
w1     Ready    <none>          5h50m   v1.34.3+k3s1
w2     Ready    <none>          5h47m   v1.34.3+k3s1
```
## Worker Node 실행 중지 후 다음 명령
### 노드가 죽어도 컨트롤플레인이 바로 NotReady로 바꾸지 않고, 일정 시간(헬스체크/하트비트 유예)을 보고 상태를 바꾸는 경우가 흔합니다. 그래서 -w로 보고 있어도 “몇십 초~수 분” 지연이 생길 수 있어요
---
```bash
ubuntu@cp1:~$ kubectl get nodes -w
NAME   STATUS     ROLES           AGE     VERSION
cp1    Ready      control-plane   6h3m    v1.34.3+k3s1
w1     NotReady   <none>          5h51m   v1.34.3+k3s1
w2     NotReady   <none>          5h48m   v1.34.3+k3s1
```


## 1. 기본 개념 비교

| 항목              | Pod                                              | Node (노드)                                          |
|-------------------|--------------------------------------------------|------------------------------------------------------|
| 개념              | Kubernetes의 **가장 작은 배포 단위**              | 클러스터를 구성하는 **실제 워커 머신** (물리/가상 서버) |
| 역할              | 하나 이상의 컨테이너를 실행하는 논리적 그룹        | Pod들을 실제로 실행·관리하는 물리적/가상 인프라         |
| 생성 주체         | 사용자 / Deployment / StatefulSet / Job 등        | 클러스터 관리자 또는 autoscaler가 서버를 추가할 때     |
| 수명 주기         | 매우 짧음 (삭제·재시작·스케일링 시 자주 생성/소멸) | 매우 길음 (서버가 살아있는 동안 지속)                  |
| IP 주소           | Pod마다 고유한 클러스터 내부 IP 할당              | Node 자체도 IP 있음 (Pod IP와 별개)                    |
| 스케줄링 대상     | Kubernetes 스케줄러가 적절한 Node에 배치           | 사람이 직접 추가하거나 kubelet 등록                   |
| 여러 개 실행 가능 | 하나의 Node 위에 **여러 개의 Pod** 동시 실행 가능 | 하나의 클러스터에 **여러 개의 Node** 존재 가능        |
| 장애 시 동작      | Pod 장애 → 컨트롤러가 자동으로 새 Pod 생성         | Node 장애 → 해당 Node의 모든 Pod가 다른 Node로 재배치  |
| 관리 관점         | **애플리케이션** 중심 (Deployment, ReplicaSet 등) | **인프라** 중심 (클러스터 autoscaler, 노드 유지보수)   |
| 대표 명령어       | `kubectl get pods`<br>`kubectl describe pod`     | `kubectl get nodes`<br>`kubectl describe node`        |

## 2. 핵심 차이점 요약 (가장 중요한 3가지)

1. **추상화 수준**  
   - **Pod** : 애플리케이션 레벨의 추상화  
     → 어떤 컨테이너들을 어떻게 같이 실행할 것인가  
   - **Node** : 인프라 레벨의 추상화  
     → 어떤 물리적/가상 서버에 Pod를 올릴 것인가

2. **생명 주기**  
   - **Pod** : 일시적이며 빈번하게 생성·소멸  
     (스케일링, 롤링 업데이트, 장애 복구 등 정상 운영 중에도 자주 발생)  
   - **Node** : 가능한 한 장기간 유지되어야 하는 서버  
     (하드웨어 교체, OS 업그레이드 등으로만 교체됨)

3. **계층 관계**
```
클러스터
├─ Node 1
│     ├─ Pod A (nginx + filebeat)
│     ├─ Pod B (backend-api)
│     └─ Pod C (redis)
├─ Node 2
│     ├─ Pod D (frontend)
│     └─ Pod E (worker)
└─ Node 3
└─ ...
```
text## 3. 실무적 비유
Node  = 건물 (데이터센터의 물리/가상 서버)
Pod   = 건물 안에 입주해 있는 세입자 (실행 중인 애플리케이션)
• 건물(Node)은 최대한 오래 안정적으로 유지·관리
• 세입자(Pod)는 이사(삭제), 새 입주(생성)가 매우 빈번함
text## 4. 실무에서 자주 비교되는 추가 항목

| 항목                        | Pod                                      | Node                                          |
|-----------------------------|------------------------------------------|-----------------------------------------------|
| 리소스 requests/limits      | 적용 (컨테이너 단위)                      | 적용 (kubelet이 Node 전체 리소스 관리)         |
| taints & tolerations        | tolerations 설정                         | taints 설정 (특정 Pod 배치 제한)              |
| node affinity / selector    | Pod에서 Node 선택 조건 설정               | Node 자체에 속성 부여                          |
| 장애 격리 범위              | Pod 단위 (다른 Pod 영향 최소)             | Node 단위 (같은 Node 내 모든 Pod 영향)        |
| autoscaling 대상            | HPA (Horizontal Pod Autoscaler)          | Cluster Autoscaler / Karpenter                |
| 모니터링 포커스             | 애플리케이션/컨테이너 메트릭               | OS, kubelet, 하드웨어, 컨테이너 런타임 메트릭   |

## 요약 (한 문장)

**Pod**는 애플리케이션 실행 단위를 나타내는 **논리적 개념**이며,  
**Node**는 그 Pod를 실제로 실행하는 **물리적/가상 인프라**입니다.

---

## 쿠버네티스 매니페스트(Manifest) 는 “클러스터에 적용할 리소스 정의서”이고, 보통 YAML 형식으로 작성합니다. 아래는 형식(필수 필드) 과 자주 쓰는 예시들입니다.

### 1) 매니페스트 기본 형식(공통 골격)
```
apiVersion: <리소스가 속한 API 버전>
kind: <리소스 종류>
metadata:
  name: <이름>
  namespace: <네임스페이스>   # 선택 (없으면 default)
  labels:                    # 선택
    app: myapp
spec:                        # 리소스별로 내용이 달라짐
  ...
```
---

```
apiVersion: 예) v1, apps/v1, autoscaling/v2

kind: 예) Pod, Deployment, Service, Ingress, ConfigMap, Secret

metadata.name: 리소스 이름(네임스페이스 내 유니크)

spec: “원하는 상태(Desired State)” 정의
```
---
### 2) 여러 리소스를 한 파일에 넣기 (--- 구분자)
```
apiVersion: v1
kind: Namespace
metadata:
  name: demo
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: demo-config
  namespace: demo
data:
  APP_MODE: "dev"
```
---

적용:
```
kubectl apply -f file.yaml
```
### 3) Pod 예시(가장 단순)
```
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
spec:
  containers:
  - name: nginx
    image: nginx:1.27-alpine
    ports:
    - containerPort: 80
```
---

### 4) Deployment 예시(실무 기본, Replica 관리)
```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
  namespace: demo
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.27-alpine
        ports:
        - containerPort: 80
        resources:
          requests:
            cpu: "50m"
            memory: "64Mi"
          limits:
            cpu: "300m"
            memory: "128Mi"
```
---

### 5) Service 예시(파드 앞단 고정 주소)
ClusterIP (클러스터 내부용, 기본)
```
apiVersion: v1
kind: Service
metadata:
  name: nginx-svc
  namespace: demo
spec:
  selector:
    app: nginx
  ports:
  - port: 80
    targetPort: 80

NodePort (노드 IP:포트로 외부 노출)
apiVersion: v1
kind: Service
metadata:
  name: nginx-nodeport
  namespace: demo
spec:
  type: NodePort
  selector:
    app: nginx
  ports:
  - port: 80
    targetPort: 80
    nodePort: 30080   # 보통 30000~32767
```
---

### 6) Ingress 예시(k3s 기본 Traefik과 함께 많이 씀)

k3s는 Traefik이 기본 Ingress Controller로 들어오는 경우가 많습니다.
```
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: nginx-ing
  namespace: demo
spec:
  rules:
  - host: nginx.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: nginx-svc
            port:
              number: 80
```
---

### 7) HPA 예시(오토스케일, CPU 기준)
```
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: nginx-hpa
  namespace: demo
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: nginx
  minReplicas: 2
  maxReplicas: 4
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 50
```
---
### 8) ConfigMap / Secret 예시
```
ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
  namespace: demo
data:
  APP_MODE: "prod"
  LOG_LEVEL: "info"

Secret (주의: base64 인코딩 필요)
apiVersion: v1
kind: Secret
metadata:
  name: db-secret
  namespace: demo
type: Opaque
data:
  username: dXNlcg==   # "user" base64
  password: cGFzcw==   # "pass" base64
```
---
### 9) 자주 쓰는 kubectl 명령
```
kubectl apply -f app.yaml
kubectl get all -n demo
kubectl describe deploy/nginx -n demo
kubectl logs -n demo deploy/nginx
kubectl delete -f app.yaml
```